/********************************************************************
* driver.cpp - driver for Decaf
*
********************************************************************/

#include <cstdio>
#include <sstream>
#include <cstdio>
#include "lexer.h"
#include "ast.h"
#include "error.h"
#include "tables.h"
#include "parser.h"
#include "IR.h"
#include "visitor.h"

extern std::istream* input;

int no_lex_Errors = 0;
int no_par_Errors = 0;

void
initFrontEnd(std::string Str)
{
    makeBinOpTable();
    makeTypePrecTable();
    makeWidthTable(); 
    makeEnvRootTop();

    std::string tmp_Str = ("" == Str)?"std::cin":Str; 
    std::cout << "-----------------------------------------------\n";
    std::cout << "code generated for " << tmp_Str << "\n";
    std::cout << "-----------------------------------------------\n";

    std::vector<std::string> labels;
    IR_Line* line_1 = new SSA_Entry(token(tok_plus), "t1", "a", "4", "Env1", labels);
    std::string label("L1");
    labels.push_back(label);
    IR_Line* line_2 = new SSA_Entry(token(tok_le), "t2", "t1", "b", "Env1", labels);
    label = "L2";
    labels.push_back(label);
    IR_Line* line_3 = new SSA_Entry(token(tok_div), "t3", "t1", "t2", "Env1", labels);

    insertLine(line_1);
    insertLine(line_2);
    insertLine(line_3);
    printIR_List();

    delete line_1;
    delete line_2;
    delete line_3;

}

void // change to a list type ***TO DO***
collectParts() // will collect parts (functions, classes, main,...)
{

}

void // TO DO: update when ready
startParse(void)
{
    top_Env = addEnv(top_Env);
    IdExpr_AST* a = new IdExpr_AST(token(tok_int), token(tok_ID, "a"));
    addIdToEnv(top_Env, a, "stack");
    IdExpr_AST* b = new IdExpr_AST(token(tok_int), token(tok_ID, "b"));
    addIdToEnv(top_Env, b, "stack");
    IdExpr_AST* c = new IdExpr_AST(token(tok_int), token(tok_ID, "c"));
    addIdToEnv(top_Env, c, "stack");

    std::cout << "\n";
    printEnvAncestorInfo(top_Env);
    printSTInfo();
    std::cout << "\n";

    getNextToken();
    while (*input){
	try{
	    parseExpr(0);
	}
	catch(Lexer_Error& m){
	    m.print();
	    panicModeFwd();
	}

	catch(Primary_Error& m){
	    m.print();
	    panicModeFwd();
	}
	catch(Punct_Error& m){
	    m.print();
	    panicModeFwd();
	}
    }

    if (no_lex_Errors)
	std::cerr << "found " << no_lex_Errors << " lexical errors\n";

    if (no_par_Errors)
	std::cerr << "found "<< no_par_Errors << " syntactic/semantic errors\n";
}

void // ***TO DO: better a method for each Error type (as we forward
panicModeFwd(void) // in different ways)
{
    int c;

    if ( ('\n' != last_Char) && (EOF != last_Char) ){
	while( ('\n' != (c = getNext())) && (';' != c) )
	    ;
    }

    if (EOF != last_Char)
	getNext();
}

